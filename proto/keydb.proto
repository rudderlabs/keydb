syntax = "proto3";

package keydb;

option go_package = "github.com/rudderlabs/keydb/proto";

// KeyDB service definitions

// NodeService handles the core key-value operations
service NodeService {
  // Get retrieves values for multiple keys
  rpc Get(GetRequest) returns (GetResponse) {}

  // Put stores multiple key-value pairs with TTL
  rpc Put(PutRequest) returns (PutResponse) {}

  // GetNodeInfo returns information about the node and the cluster
  rpc GetNodeInfo(GetNodeInfoRequest) returns (GetNodeInfoResponse) {}

  // LoadSnapshots forces the node to load all snapshots from cloud storage
  rpc LoadSnapshots(LoadSnapshotsRequest) returns (LoadSnapshotsResponse) {}

  // CreateSnapshots forces the creation of snapshots for all hash ranges
  rpc CreateSnapshots(CreateSnapshotsRequest) returns (CreateSnapshotsResponse) {}

  // SendSnapshot is called by scaler on source node to initiate streaming to destination
  rpc SendSnapshot(SendSnapshotRequest) returns (SendSnapshotResponse) {}

  // GetSnapshotSince is called by source node to get "since" timestamp from destination
  rpc GetSnapshotSince(GetSnapshotSinceRequest) returns (GetSnapshotSinceResponse) {}

  // ReceiveSnapshot is called by source node to stream snapshot data to destination
  rpc ReceiveSnapshot(stream SnapshotChunk) returns (ReceiveSnapshotResponse) {}
}

// NodeService message definitions

// GetRequest contains multiple keys to retrieve
message GetRequest {
  repeated string keys = 1;
}

// GetResponse contains the retrieved values and cluster information
message GetResponse {
  repeated bool exists = 1; // This list should be populated in the same order as the "keys" field in GetRequest
  int64 cluster_size = 2; // Number of nodes in the cluster
  repeated string nodesAddresses = 3; // When the cluster_size changes the client can use this variable to connect to the new nodes
  ErrorCode error_code = 4; // If WRONG_NODE or SCALING is received the client should get the new cluster size via GetNodeInfo and retry
}

// PutRequest contains multiple key-value pairs to store
// The client will automatically split PutRequest into multiple ones, one per node depending on the keys and hash-ranges
// Then the requests are sent in parallel to all the concerned nodes and put back into a single PutResponse
message PutRequest {
  repeated string keys = 1;
  int64 ttl_seconds = 2;
  ErrorCode error_code = 3; // If WRONG_NODE or SCALING is received the client should get the new cluster size via GetNodeInfo and retry
}

// PutResponse contains the operation result and cluster information
message PutResponse {
  bool success = 1;
  int64 cluster_size = 2; // Number of nodes in the cluster
  repeated string nodesAddresses = 3; // When the cluster_size changes the client can use this variable to connect to the new nodes
  ErrorCode error_code = 4; // If WRONG_NODE or SCALING is received the client should get the new cluster size via GetNodeInfo and retry
}

// ErrorCode enum for different types of errors
enum ErrorCode {
  NO_ERROR = 0;
  WRONG_NODE = 1; // Key should be handled by a different node
  SCALING = 2; // There is a scaling operation in progress, the client should retry with an exponential backoff
  INTERNAL_ERROR = 3;
}

// GetNodeInfoRequest to retrieve information about a node
message GetNodeInfoRequest {
  int64 node_id = 1; // ID of the node to get info from
}

// GetNodeInfoResponse contains information about the node and the cluster
message GetNodeInfoResponse {
  int64 node_id = 1; // ID of the node
  int64 cluster_size = 2; // Number of nodes in the cluster
  repeated string nodesAddresses = 3; // When the cluster_size changes the client can use this variable to connect to the new nodes
  repeated int64 hash_ranges = 4; // Hash ranges handled by this node
  int64 last_snapshot_timestamp = 5; // Unix timestamp of the last snapshot
}

// LoadSnapshotsRequest initiates loading snapshots from cloud storage
message LoadSnapshotsRequest {
  repeated int64 hash_range = 1; // repeated means 0 or more values, pass none to load all snapshots handled by that node
  int64 max_concurrency = 2; // how many snapshots should be downloaded concurrently and loaded up (affects node memory)
}

// LoadSnapshotsResponse contains the result of the snapshot loading operation
message LoadSnapshotsResponse {
  bool success = 1;
  string error_message = 2; // Error message if the operation failed
  int64 node_id = 3; // ID of the node that processed the request
}

// CreateSnapshotRequests initiates snapshot creation
message CreateSnapshotsRequest {
  repeated int64 hash_range = 1; // repeated means 0 or more values, pass none to create all snapshots
  bool full_sync = 2; // pass true to force the nodes to create snapshots from scratch (not incremental)
}

// CreateSnapshotsResponse contains the result of the snapshot creation
message CreateSnapshotsResponse {
  bool success = 1;
  string error_message = 2; // Error message if the operation failed
  int64 node_id = 3; // ID of the node that processed the request
}

// SendSnapshotRequest initiates streaming a hash range to a destination node
message SendSnapshotRequest {
  int64 hash_range = 1;            // Hash range to send
  string destination_address = 2;  // Target node address (host:port)
}

// SendSnapshotResponse contains the result of the send snapshot operation
message SendSnapshotResponse {
  bool success = 1;
  string error_message = 2;
  int64 node_id = 3;               // ID of the node that processed the request
}

// GetSnapshotSinceRequest asks for the "since" timestamp for incremental snapshots
message GetSnapshotSinceRequest {
  int64 hash_range = 1;            // Which hash range to query
}

// GetSnapshotSinceResponse returns the timestamp for incremental snapshots
message GetSnapshotSinceResponse {
  uint64 since_timestamp = 1;      // 0 means full sync needed
}

// SnapshotChunk represents a chunk of snapshot data being streamed
message SnapshotChunk {
  int64 hash_range = 1;            // Which hash range this chunk belongs to
  bytes data = 2;                  // Chunk of snapshot data
  bool is_last = 3;                // Whether this is the final chunk
  uint64 timestamp = 4;            // Snapshot timestamp (for tracking)
}

// ReceiveSnapshotResponse contains the result of receiving a streamed snapshot
message ReceiveSnapshotResponse {
  bool success = 1;
  string error_message = 2;
}
